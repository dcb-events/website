{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is it?","text":"<p>DCB is a technique for enforcing consistency in an event-driven system.</p> <p>Event-driven applications have proven to be very effective solutions for distributed systems, allowing temporal and spatial decoupling.</p> <p>Nevertheless, they come with some downsides. First of all, the well-known eventual consistency issue. The temporal decoupling between the moment an event is published and the moment it is handled generates a gap between the happening fact and its effective propagation and visibility across the system. How large this gap is depends on many factors and can go from a few milliseconds to a very long interval, like hours or even days sometimes. As a consequence, the decisions the system makes based on the projected state are potentially inaccurate since they are based on potentially obsolete information.</p> <p>In the majority of cases, this is not a problem at all.</p> <p>Nevertheless, there are a few situations where it is crucial to avoid mistakes caused by data obsolescence. In these situations, it is paramount to base the decision on the latest information, including those contained in the events already published but not yet handled, still on the fly.</p> <p>There are many solutions to this problem. DCB is one of them.</p> <p>Each event published in a specific context is identified by a global sequential index.</p> <p>Every time the system requires some data to make a decision, it is essential to know how up-to-date those data are. This is possible with a consistency marker \u2014 nothing more than the identifier of the latest event the projected data are aware of.</p> <p>The decision results in one or more events to be published.</p> <p>Since the data used for making the decision are frozen in time at the moment identified by the consistency marker, the publishing operation needs to be performed only conditionally. The condition that must be fulfilled is that no events that could affect the decision that was just made happened after the consistency marker.</p> <p>DCB acts as a form of optimistic lock for publishing events.</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#how-it-works","title":"How it works","text":""},{"location":"#limitations","title":"Limitations","text":"<p>DCB could guarantee consistency only inside the scope of the global sequential index. Indeed, the events must be ordered to allow the conditional publication based on the consistency marker.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Some common questions and misconceptions about DCB:</p>"},{"location":"faq/#does-it-promote-lack-of-modeling","title":"Does it promote lack of modeling?","text":"<p>tbd: no :)</p>"},{"location":"faq/#is-it-about-less-strict-consistency-boundaries","title":"Is it about less strict consistency boundaries?","text":"<p>tbd: name might suggest that, but no :)</p>"},{"location":"faq/#how-does-it-improve-performance","title":"How does it improve performance?","text":"<p>tbd: performance is not the intention of DCB, for large scale &amp; high performance eventual consistency is even required. Link to performance</p>"},{"location":"faq/#how-does-it-scale","title":"How does it scale?","text":"<p>tbd: considerations, link to performance</p>"},{"location":"faq/#does-it-increase-chances-of-lock-collisions","title":"Does it increase chances of lock collisions?","text":"<p>tbd: no, chances for collisions are smaller because optimistic lock only around required event types / tags</p>"},{"location":"faq/#how-can-it-be-used-with-a-classical-event-store","title":"How can it be used with a \"classical\" event store?","text":"<p>tbd: link to DCB with a \"classical\" Event Store</p>"},{"location":"faq/#why-do-you-want-to-kill-aggregates","title":"Why do you want to kill aggregates?","text":"<p>tbd: link to example / article about \"Aggregate with DCB\"</p>"},{"location":"glossary/","title":"Glossary","text":"<p>Disclaimer</p> <p>The definitions in this list merely reflect our personal take and are not meant to be authoritive! However, feel free to report any invalid/missing information in the bugtracker of this website</p>"},{"location":"glossary/#command","title":"Command","text":"<p>An instruction to perform a specific action or change in a system, typically resulting in one or more events if successfully processed</p>"},{"location":"glossary/#cqrs-command-query-responsibility-segregation","title":"CQRS (Command Query Responsibility Segregation)","text":"<p>A pattern that separates the responsibilities of handling commands (write operations) and queries (read operations) to optimize and scale each independently</p>"},{"location":"glossary/#decision-model","title":"Decision Model","text":"<p>A representation of the rules and logic used to process commands and decide which events should be generated in response</p>"},{"location":"glossary/#domain-driven-design","title":"Domain-Driven Design","text":"<p>A software design approach that focuses on modeling a system based on the core domain, using the language and concepts of domain experts</p>"},{"location":"glossary/#event","title":"Event","text":"<p>A record of a change or action that has occurred in the past, capturing significant domain-relevant information</p>"},{"location":"glossary/#event-sourcing","title":"Event Sourcing","text":"<p>A pattern where changes are stored as a sequence of events, rather than overwriting the current state</p> <p>Info</p> <p>DCB can be used without Event Sourcing, see DCB without Event Sourcing</p>"},{"location":"glossary/#event-store","title":"Event Store","text":"<p>A specialized storage system for events that ensures they are stored sequentially and can be retrieved efficiently</p>"},{"location":"glossary/#eventual-consistency","title":"Eventual Consistency","text":"<p>A state where data across a distributed system becomes consistent over time, without requiring immediate synchronization</p>"},{"location":"glossary/#projection","title":"Projection","text":"<p>Deriving state from a series of events</p> <p>Projections can be used to persist read models; however, since DCB primarily focuses on the write side, this website typically refers to projections used to construct an in-memory decision model.</p> <p>Essentially, a projection can be implemented as a function that takes the current state and an event as inputs and returns the updated state:</p> <pre><code>fn (state, event) =&gt; state\n</code></pre>"},{"location":"glossary/#read-model","title":"Read Model","text":"<p>A representation of data tailored for specific read operations, often denormalized for performance</p>"},{"location":"glossary/#read-side","title":"Read Side","text":"<p>The part of a system responsible for querying and presenting data, typically optimized for read operations</p>"},{"location":"glossary/#sequence","title":"Sequence","text":"<p>An ordered series of events that represent changes over time</p>"},{"location":"glossary/#sequence-number","title":"Sequence Number","text":"<p>A unique, incremental identifier assigned to events, ensuring their correct order within a stream</p>"},{"location":"glossary/#state","title":"State","text":"<p>The current condition or snapshot of a system or entity, derived from a sequence of past events</p>"},{"location":"glossary/#view-model","title":"View Model","text":"<p>See Read Model</p>"},{"location":"glossary/#write-side","title":"Write Side","text":"<p>The part of a system that processes commands, enforces business rules, and generates events</p>"},{"location":"advanced/","title":"Index","text":"<p>intro about advanced topics (tbd)</p>"},{"location":"advanced/composing-projections/","title":"Composing projections","text":""},{"location":"advanced/composing-projections/#requirement-1-enforce-unique-course-ids","title":"Requirement 1: Enforce unique course ids","text":"<p><pre><code>const events = [\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  }\n];\n\nconst courseExists = (courseId) =&gt; {\n  const projection = {\n    $init: () =&gt; false,\n    COURSE_CREATED: () =&gt; true,\n  };\n  return events\n    .filter(event =&gt; event.tags.includes(`course:${courseId}`))\n    .reduce((state, event) =&gt;\n      projection[event.type]?.(state, event) ?? state,\n      projection.$init?.()\n    );\n};\n\nfor (const courseId of ['c1', 'c2']) {\n  console.log(`course \"${courseId}\" ${courseExists(courseId) ? 'exists' : 'does not exist'}`);\n}\n</code></pre> </p>"},{"location":"advanced/composing-projections/#library","title":"Library","text":"<p>(tbd)</p> <pre><code>type Event&lt;TData = any&gt; = {\n  type: string;\n  data: TData;\n  tags?: string[];\n};\n\ntype Mapping&lt;TState, TEvent extends Event&gt; = {\n  $init: () =&gt; TState;\n  [eventType: string]: ((state: TState, event: TEvent) =&gt; TState) | (() =&gt; TState);\n};\n\ntype Projection&lt;TState, TEvent extends Event&gt; = {\n  initialState: () =&gt; TState | null;\n  apply: (state: TState, event: TEvent) =&gt; TState;\n};\n\ndeclare function projection&lt;TState, TEvent extends Event&gt;(\n  mapping: Mapping&lt;TState, TEvent&gt;,\n  tag: string\n): Projection&lt;TState, TEvent&gt;;\n\ndeclare function buildDecisionModel&lt;TProjections extends Record&lt;string, Projection&lt;any, Event&gt;&gt;&gt;(\n  projections: TProjections\n): {\n  [K in keyof TProjections]: ReturnType&lt;TProjections[K]['initialState']&gt;;\n};\n</code></pre> <p>As a result, the example from above can be simplified:</p> <p><pre><code>const events = [\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  }\n];\n\nconst courseExists = (courseId) =&gt; projection({\n  $init: () =&gt; false,\n  COURSE_CREATED: () =&gt; true,\n}, `course:${courseId}`);\n\nfor (const courseId of ['c1', 'c2']) {\n  const decisionModel = buildDecisionModel({\n    courseExists: courseExists(courseId)\n  })\n  console.log(`course \"${courseId}\" ${decisionModel.courseExists ? 'exists' : 'does not exist'}`);\n}\n</code></pre> </p>"},{"location":"advanced/composing-projections/#requirement-2-respect-course-capacity","title":"Requirement 2: Respect course capacity","text":"<p>adding a <code>courseCapacity</code> projection to keep track of the total capacity of a course:</p> <p><pre><code>const events = [\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"COURSE_CAPACITY_CHANGED\",\n    data: { courseId: \"c1\", newCapacity: 2 },\n    tags: [\"course:c1\"],\n  }\n];\n\nconst courseCapacity = (courseId) =&gt; projection({\n  $init: () =&gt; 0,\n  COURSE_CREATED: (_, event) =&gt; event.data.capacity,\n  COURSE_CAPACITY_CHANGED: (_, event) =&gt; event.data.newCapacity,\n}, `course:${courseId}`);\n\nconst courseId = 'c1';\nconst decisionModel = buildDecisionModel({\n    courseCapacity: courseCapacity(courseId),\n})\nconsole.log(`course \"${courseId}\" has a total capacity of ${decisionModel.courseCapacity}`);\n</code></pre> </p> <p>adding a <code>numberOfCourseSubscriptions</code> projection to keep a count of the subscribed students</p> <p><pre><code>const events = [\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c1\" },\n    tags: [\"student:s1\", \"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s2\", courseId: \"c1\" },\n    tags: [\"student:s2\", \"course:c1\"],\n  },\n];\n\nconst numberOfCourseSubscriptions = (courseId) =&gt; projection({\n  $init: () =&gt; 0,\n  STUDENT_SUBSCRIBED_TO_COURSE: (state) =&gt; state + 1,\n}, `course:${courseId}`);\n\nconst courseId = 'c1';\nconst decisionModel = buildDecisionModel({\n    numberOfCourseSubscriptions: numberOfCourseSubscriptions(courseId),\n})\nconsole.log(`course \"${courseId}\" currently has ${decisionModel.numberOfCourseSubscriptions} subscriptions`);\n</code></pre> </p>"},{"location":"advanced/composing-projections/#composition","title":"Composition","text":"<p>Now those three projections <code>courseExists</code>, <code>courseCapacity</code> and <code>numberOfCourseSubscriptions</code> can be combined to create a single decision model:</p> <p><pre><code>const events = [\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c2\", capacity: 15 },\n    tags: [\"course:c2\"],\n  },\n  {\n    type: \"COURSE_CAPACITY_CHANGED\",\n    data: { courseId: \"c1\", newCapacity: 2 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c1\" },\n    tags: [\"student:s1\", \"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c2\" },\n    tags: [\"student:s1\", \"course:c2\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s2\", courseId: \"c1\" },\n    tags: [\"student:s2\", \"course:c1\"],\n  },\n];\n\nconst courseExists = (courseId) =&gt; projection({\n  $init: () =&gt; false,\n  COURSE_CREATED: () =&gt; true,\n}, `course:${courseId}`);\n\nconst courseCapacity = (courseId) =&gt; projection({\n  $init: () =&gt; 0,\n  COURSE_CREATED: (_, event) =&gt; event.data.capacity,\n  COURSE_CAPACITY_CHANGED: (_, event) =&gt; event.data.newCapacity,\n}, `course:${courseId}`);\n\nconst numberOfCourseSubscriptions = (courseId) =&gt; projection({\n  $init: () =&gt; 0,\n  STUDENT_SUBSCRIBED_TO_COURSE: (state) =&gt; state + 1,\n}, `course:${courseId}`);\n\nfor (const courseId of ['c1', 'c2', 'c3']) {\n  const decisionModel = buildDecisionModel({\n    courseExists: courseExists(courseId),\n    courseCapacity: courseCapacity(courseId),\n    numberOfCourseSubscriptions: numberOfCourseSubscriptions(courseId),\n  })\n  const remainingSeats = decisionModel.courseCapacity - decisionModel.numberOfCourseSubscriptions;\n  console.log(`course \"${courseId}\" (capacity: ${decisionModel.courseCapacity}) ${decisionModel.courseExists ? 'exists' : 'does not exist'} and has ${remainingSeats} seats left`);\n}\n</code></pre> </p>"},{"location":"advanced/composing-projections/#requirement-3-student-must-not-be-subscribed-to-the-same-course-twice","title":"Requirement 3: Student must not be subscribed to the same course twice","text":"<p><pre><code>const events = [\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c1\" },\n    tags: [\"student:s1\", \"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c2\" },\n    tags: [\"student:s1\", \"course:c2\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s2\", courseId: \"c1\" },\n    tags: [\"student:s2\", \"course:c1\"],\n  },\n];\n\nconst studentSubscriptions = (studentId) =&gt; projection({\n  $init: () =&gt; [],\n  STUDENT_SUBSCRIBED_TO_COURSE: (state, event) =&gt; [...state, event.data.courseId],\n}, `student:${studentId}`);\n\nfor (const studentId of [\"s1\", \"s2\"]) {\n  const decisionModel = buildDecisionModel({\n      studentSubscriptions: studentSubscriptions(studentId),\n  })\n  console.log(`student ${studentId} is subscribed to the courses ${decisionModel.studentSubscriptions}`)\n}\n</code></pre> </p> <p>Finally, everything can be combined to implement a command handler <code>subscribeStudentToCourse</code> that enforces all requirements:</p> <p><pre><code>const events = [\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"COURSE_CREATED\",\n    data: { courseId: \"c2\", capacity: 15 },\n    tags: [\"course:c2\"],\n  },\n  {\n    type: \"COURSE_CAPACITY_CHANGED\",\n    data: { courseId: \"c1\", newCapacity: 2 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c1\" },\n    tags: [\"student:s1\", \"course:c1\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s1\", courseId: \"c2\" },\n    tags: [\"student:s1\", \"course:c2\"],\n  },\n  {\n    type: \"STUDENT_SUBSCRIBED_TO_COURSE\",\n    data: { studentId: \"s2\", courseId: \"c1\" },\n    tags: [\"student:s2\", \"course:c1\"],\n  },\n];\n\nconst courseExists = (courseId) =&gt; projection({\n  $init: () =&gt; false,\n  COURSE_CREATED: () =&gt; true,\n}, `course:${courseId}`);\n\nconst courseCapacity = (courseId) =&gt; projection({\n  $init: () =&gt; 0,\n  COURSE_CREATED: (_, event) =&gt; event.data.capacity,\n  COURSE_CAPACITY_CHANGED: (_, event) =&gt; event.data.newCapacity,\n}, `course:${courseId}`);\n\nconst numberOfCourseSubscriptions = (courseId) =&gt; projection({\n  $init: () =&gt; 0,\n  STUDENT_SUBSCRIBED_TO_COURSE: (state) =&gt; state + 1,\n}, `course:${courseId}`);\n\nconst studentSubscriptions = (studentId) =&gt; projection({\n  $init: () =&gt; [],\n  STUDENT_SUBSCRIBED_TO_COURSE: (state, event) =&gt; [...state, event.data.courseId],\n}, `student:${studentId}`);\n\nconst subscribeStudentToCourse = (studentId, courseId) =&gt; {\n  const decisionModel = buildDecisionModel({\n      courseExists: courseExists(courseId),\n      courseCapacity: courseCapacity(courseId),\n      numberOfCourseSubscriptions: numberOfCourseSubscriptions(courseId),\n      studentSubscriptions: studentSubscriptions(studentId),\n  })\n  if (!decisionModel.courseExists) {\n      throw new Error(\"course not found\");\n  }\n  if (decisionModel.numberOfCourseSubscriptions &gt;= decisionModel.courseCapacity) {\n      throw new Error(\"course is full\");\n  }\n  if (decisionModel.studentSubscriptions.includes(courseId)) {\n      throw new Error(\"already subscribed\");\n  }\n  // TODO publish STUDENT_SUBSCRIBED_TO_COURSE event\n}\n\nfor (const {studentId,courseId} of [{studentId:\"s1\", courseId:\"c0\"},{studentId:\"s1\", courseId:\"c1\"},{studentId:\"s1\", courseId:\"c2\"},{studentId:\"s2\", courseId:\"c2\"}]) {\n  console.log(`Subscribing student ${studentId} to course ${courseId}...`)\n  try {\n    subscribeStudentToCourse(studentId, courseId)\n    console.log(\"success\")\n  } catch (e) {\n    console.log(`Error: ${e.message}\\n`)\n  }\n}\n</code></pre> </p>"},{"location":"examples/","title":"Index","text":"<p>intro about examples (tbd)</p>"},{"location":"examples/idempotency/","title":"Idempotency","text":"<p>Idempotency....</p>"},{"location":"examples/reservation-pattern/","title":"Reservation pattern","text":"<p>Reservation pattern...</p>"},{"location":"examples/uniqueness/","title":"Uniqueness across entities","text":"<p>Uniqueness across...</p>"},{"location":"examples/uniqueness/#example-01","title":"Example 01","text":"<p>This example is the most simple one just checking whether a given username is claimed</p> <pre><code>const events = [\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a1\", username: \"u1\" },\n    tags: [\"account:a1\", \"username:u1\"],\n  },\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a2\", username: \"u2\" },\n    tags: [\"account:a2\", \"username:u2\"],\n  },\n];\n\nconst isUsernameClaimed = (username) =&gt; {\n  const projection = {\n    $init: () =&gt; false,\n    ACCOUNT_REGISTERED: () =&gt; true,\n  };\n  return events\n    .filter(event =&gt; event.tags.includes(`username:${username}`))\n    .reduce((state, event) =&gt; projection[event.type]?.(state, event) ?? state, projection.$init?.());\n};\n\nfor (const username of ['u1', 'u2', 'u3', 'u4']) {\n  console.log(`username \"${username}\" is ${isUsernameClaimed(username) ? 'taken' : 'free'}`);\n}\n</code></pre> <p></p>"},{"location":"examples/uniqueness/#example-02","title":"Example 02","text":"<p>This example extends the previous one to show how a previously claimed username could be released whent the corresponding account is suspended</p> <pre><code>const events = [\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a1\", username: \"u1\" },\n    tags: [\"account:a1\", \"username:u1\"],\n  },\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a2\", username: \"u2\" },\n    tags: [\"account:a2\", \"username:u2\"],\n  },\n  {\n    type: \"ACCOUNT_SUSPENDED\",\n    data: { id: \"a1\" },\n    tags: [\"account:a2\", \"username:u1\"],\n  }\n];\n\nconst isUsernameClaimed = (username) =&gt; {\n  const projection = {\n    $init: () =&gt; false,\n    ACCOUNT_REGISTERED: () =&gt; true,\n    ACCOUNT_SUSPENDED: () =&gt; false,\n  };\n  return events\n    .filter(event =&gt; event.tags.includes(`username:${username}`))\n    .reduce((state, event) =&gt; projection[event.type]?.(state, event) ?? state, projection.$init?.());\n};\n\nfor (const username of ['u1', 'u2', 'u3', 'u4']) {\n  console.log(`username \"${username}\" is ${isUsernameClaimed(username) ? 'taken' : 'free'}`);\n}\n</code></pre> <p></p>"},{"location":"examples/uniqueness/#example-03","title":"Example 03","text":"<p>This example extends the previous one to show how the username of an active account could be changed</p> <pre><code>const events = [\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a1\", username: \"u1\" },\n    tags: [\"account:a1\", \"username:u1\"],\n  },\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a2\", username: \"u2\" },\n    tags: [\"account:a2\", \"username:u2\"],\n  },\n  {\n    type: \"ACCOUNT_SUSPENDED\",\n    data: { id: \"a1\" },\n    tags: [\"account:a2\", \"username:u1\"],\n  },\n  {\n    type: \"USERNAME_CHANGED\",\n    data: { id: \"a2\", newUsername: \"u3\" },\n    tags: [\"account:a2\", \"username:u2\", \"username:u3\"], // NOTE: contains both tags, of the old and the new username\n  },\n];\n\nconst isUsernameClaimed = (username) =&gt; {\n  const projection = {\n    $init: () =&gt; false,\n    ACCOUNT_REGISTERED: () =&gt; true,\n    ACCOUNT_SUSPENDED: () =&gt; false,\n    USERNAME_CHANGED: (_, event) =&gt; event.data.newUsername === username,\n  };\n  return events\n    .filter(event =&gt; event.tags.includes(`username:${username}`))\n    .reduce((state, event) =&gt; projection[event.type]?.(state, event) ?? state, projection.$init?.());\n};\n\nfor (const username of ['u1', 'u2', 'u3', 'u4']) {\n  console.log(`username \"${username}\" is ${isUsernameClaimed(username) ? 'taken' : 'free'}`);\n}\n</code></pre> <p></p>"},{"location":"examples/uniqueness/#example-04","title":"Example 04","text":"<p>This example extends the previous one to show how the release of a username could be postponed by X days</p> <pre><code>// little helper function to generate dates X days ago\nconst daysAgo = (days) =&gt; new Date((new Date).getTime() - days * (1000 * 60 * 60 * 24));\n\nconst events = [\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a1\", username: \"u1\" },\n    tags: [\"account:a1\", \"username:u1\"],\n    recordedAt: daysAgo(5),\n  },\n  {\n    type: \"ACCOUNT_REGISTERED\",\n    data: { id: \"a2\", username: \"u2\" },\n    tags: [\"account:a2\", \"username:u2\"],\n    recordedAt: daysAgo(4),\n  },\n  {\n    type: \"ACCOUNT_SUSPENDED\",\n    data: { id: \"a1\" },\n    tags: [\"account:a2\", \"username:u1\"],\n    recordedAt: daysAgo(3),\n  },\n  {\n    type: \"USERNAME_CHANGED\",\n    data: { id: \"a2\", newUsername: \"u3\" },\n    tags: [\"account:a2\", \"username:u2\", \"username:u3\"],\n    recordedAt: daysAgo(2),\n  },\n];\n\n// number of days before a released username can be re-claimed\nconst usernameReleaseDelayInDays = 3;\n\n// little helpfer function to calculate the age of an event\nconst eventAgeInDays = (event) =&gt; (new Date - event.recordedAt) / (1000 * 60 * 60 * 24);\n\nconst isUsernameClaimed = (username) =&gt; {\n  const projection = {\n    $init: () =&gt; false,\n    ACCOUNT_REGISTERED: () =&gt; true,\n    ACCOUNT_SUSPENDED: (_, event) =&gt; eventAgeInDays(event) &lt; usernameReleaseDelayInDays,\n    USERNAME_CHANGED: (_, event) =&gt; event.data.newUsername === username || eventAgeInDays(event) &lt; usernameReleaseDelayInDays\n  };\n  return events\n    .filter(event =&gt; event.tags.includes(`username:${username}`))\n    .reduce((state, event) =&gt; projection[event.type]?.(state, event) ?? state, projection.$init?.());\n};\n\nfor (const username of ['u1', 'u2', 'u3', 'u4']) {\n  console.log(`username \"${username}\" is ${isUsernameClaimed(username) ? 'taken' : 'free'}`);\n}\n</code></pre> <p></p>"},{"location":"resources/specification/","title":"EventStore","text":""},{"location":"resources/specification/#reading","title":"Reading","text":"<p>Expects a StreamQuery and an optional starting SequenceNumber and returns an EventStream.</p> <p>Info</p> <p>The EventStore should also allow for backwards iteration on the EventStream in order to support cursor based pagination.</p>"},{"location":"resources/specification/#writing","title":"Writing","text":"<p>Expects a set of Events and an AppendCondition and returns the last appended SequenceNumber.</p>"},{"location":"resources/specification/#api","title":"API","text":"<p>A potential interface of the <code>EventStore</code> (pseudo-code):</p> <pre><code>EventStore {\n  read(query: StreamQuery, options?: ReadOptions): EventStream\n  append(events: Events|Event, condition: AppendCondition): void\n}\n</code></pre>"},{"location":"resources/specification/#readoptions","title":"ReadOptions","text":"<p>An optional parameter to <code>EventStore.read()</code> that allows for cursor-based pagination of events. It has two parameters:</p> <ul> <li><code>backwards</code> a flag that, if set to <code>true</code>, returns the events in descending order (default: <code>false</code>)</li> <li><code>from</code> an optional SequenceNumber to start streaming events from (depending on the <code>backwards</code> flag this is either a minimum or maximum sequence number of the resulting stream)</li> </ul> <pre><code>ReadOptions {\n  from?: SequenceNumber\n  backwards: bool\n}\n</code></pre>"},{"location":"resources/specification/#streamquery","title":"StreamQuery","text":"<p>The <code>StreamQuery</code> describes constraints that must be matched by Events in the EventStore It effectively allows for filtering events by their type and/or tags</p> <ul> <li>It MAY contain a set of StreamQuery Criteria \u2013 a <code>StreamQuery</code> with an empty criteria set is considered a \"wildcard\" query, i.e. it matches all events</li> </ul> <p>[!NOTE] All criteria of a StreamQuery are merged into a logical disjunction, so events match the query if they match the first OR the second criterion...</p>"},{"location":"resources/specification/#streamquery-criterion","title":"StreamQuery Criterion","text":"<p>Each criterion of a StreamQuery allows to target events by their type and/or tags</p> <p>Info</p> <p>event type filters of a single criterion are merged into a logical disjunction, so events match the criterion if they match ANY of the specified types</p> <p>tags are merged into a logical conjunction, so events match the criterion if they are tagged with ALL specified tags</p>"},{"location":"resources/specification/#example-streamquery","title":"Example StreamQuery","text":"<p>The following example query would match events that are either...</p> <ul> <li>...of type <code>EventType1</code> OR <code>EventType2</code></li> <li>...tagged <code>foo:bar</code> AND <code>baz:foos</code></li> <li>...of type <code>EventType2</code> OR <code>EventType3</code> AND tagged <code>foo:bar</code>AND <code>foo:baz</code></li> </ul> <pre><code>{\n  \"criteria\": [\n    {\n      \"event_types\": [\"EventType1\", \"EventType2\"]\n    },\n    {\n      \"tags\": [\"foo:bar\", \"baz:foos\"]\n    },\n    {\n      \"event_types\": [\"EventType2\", \"EventType3\"],\n      \"tags\": [\"foo:bar\", \"foo:baz\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"resources/specification/#sequencenumber","title":"SequenceNumber","text":"<p>When an Event is appended to the EventStore a <code>SequenceNumber</code> is assigned to it.</p> <p>It...</p> <ul> <li>MUST be unique for one EventStore</li> <li>MUST be monotonic increasing</li> <li>MUST have an allowed minimum value of <code>1</code></li> <li>CAN contain gaps</li> <li>SHOULD have a reasonably high maximum value (depending on programming language and environment)</li> </ul>"},{"location":"resources/specification/#eventstream","title":"EventStream","text":"<p>When reading from the EventStore an <code>EventStream</code> is returned.</p> <p>It...</p> <ul> <li>It MUST be iterable</li> <li>It MUST return an EventEnvelope for every iteration</li> <li>It CAN include new events if they occur during iteration</li> <li>Individual EventEnvelope instances MAY be converted during iteration for performance optimization</li> <li>Batches of events MAY be loaded from the underlying storage at once for performance optimization</li> </ul>"},{"location":"resources/specification/#eventenvelope","title":"EventEnvelope","text":"<p>Each item in the EventStream is an <code>EventEnvelope</code> that consists of the underlying event and metadata, like the SequenceNumber that was added during the <code>append()</code> call.</p> <p>It...</p> <ul> <li>It MUST contain the SequenceNumber</li> <li>It MUST contain the Event</li> <li>It CAN include more fields, like timestamps or metadata</li> </ul>"},{"location":"resources/specification/#eventenvelope-example","title":"EventEnvelope example","text":"<pre><code>{\n  \"event\": {\n    \"type\": \"SomeEventType\",\n    \"data\": \"{\\\"some\\\":\\\"data\\\"}\",\n    \"tags\": [\"type1:value1\", \"type2:value2\"]\n  },\n  \"sequence_number\": 1234,\n  \"recorded_at\": \"2024-12-10 14:02:40\"\n}\n</code></pre>"},{"location":"resources/specification/#events","title":"Events","text":"<p>A set of Event instances that is passed to the <code>append()</code> method of the EventStore</p> <p>It...</p> <ul> <li>MUST not be empty</li> <li>MUST be iterable, each iteration returning an Event</li> </ul>"},{"location":"resources/specification/#event","title":"Event","text":"<ul> <li>It MUST contain an EventType</li> <li>It MUST contain EventData</li> <li>It MAY contain Tags</li> <li>It MAY contain further fields, like metadata</li> </ul>"},{"location":"resources/specification/#potential-serialization-format","title":"Potential serialization format","text":"<pre><code>{\n  \"type\": \"SomeEventType\",\n  \"data\": \"{\\\"some\\\":\\\"data\\\"}\",\n  \"tags\": [\"key1:value1\", \"key1:value2\"]\n}\n</code></pre>"},{"location":"resources/specification/#eventtype","title":"EventType","text":"<p>String based type of the event</p> <ul> <li>It MUST satisfy the regular expression <code>^[\\w\\.\\:\\-]{1,200}$</code></li> </ul>"},{"location":"resources/specification/#eventdata","title":"EventData","text":"<p>String based, opaque payload of an Event</p> <ul> <li>It SHOULD have a reasonable large enough maximum length (depending on language and environment)</li> <li>It MAY contain JSON</li> <li>It MAY be serialized into an empty string</li> </ul>"},{"location":"resources/specification/#tags","title":"Tags","text":"<p>A set of Tag instances.</p> <ul> <li>It MUST contain at least one Tag</li> <li>It SHOULD not contain multiple Tags with the same value</li> </ul>"},{"location":"resources/specification/#tag","title":"Tag","text":"<p>A <code>Tag</code> can add domain specific metadata to an event allowing for custom partitioning</p> <p>Note</p> <p>Usually a tag represents a concept of the domain, e.g. the type and id of an entity like <code>product:p123</code></p> <ul> <li>It MUST satisfy the regular expression <code>/^[[:alnum:]\\-\\_\\:]{1,150}</code></li> </ul>"},{"location":"resources/specification/#appendcondition","title":"AppendCondition","text":"<ul> <li>It MUST contain a StreamQuery</li> <li>It MUST contain a ExpectedHighestSequenceNumber</li> </ul>"},{"location":"resources/specification/#expectedhighestsequencenumber","title":"ExpectedHighestSequenceNumber","text":"<p>Can either represent an instance of SequenceNumber Or one of:</p> <ul> <li><code>NONE</code> \u2013 No event must match the specified StreamQuery</li> <li><code>ANY</code> \u2013 Any event matches (= wildcard AppendCondition)</li> </ul>"}]}